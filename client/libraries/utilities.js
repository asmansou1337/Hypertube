const randomColor = require('random-color');
const Dictionary = require('../libraries/dictionary')
const checkUrl = require('../helpers/checkUrl');
const { uniqueNamesGenerator, colors, animals} = require('unique-names-generator');
const locales = require('../locales/locales')
var options = {
  min: 0, max: 10, 
  integer: true
}
 const Utils = {
    genUserName : async () => {
        const MAX_UNAME_LEN = 26
        const MIN_UNAME_LEN = 5
        let shortName = uniqueNamesGenerator({
            dictionaries: [colors, animals],
            length: 2
          });
        if(shortName > MAX_UNAME_LEN || shortName < MIN_UNAME_LEN)
          return Utils.getUserName()
        return shortName
    },

    genProfilePic : async (uname) => {
        // Placeholder Profile picture generated by 2 colors
        const BackColor = randomColor().hexString().replace("#", '').toUpperCase();
        const TextColor = randomColor().hexString().replace("#", '').toUpperCase();
        const ProfilePic = `http://via.placeholder.com/512/${BackColor}/${TextColor}/?text=${uname}`
        return ProfilePic
    },
    
    /**
     * Check every element of Body if it has the Allowed array elements 
     * if one element doesnt correspond,
     * or body longer or shorter than expected.
     * @param  {} Allowed  allowed body elements
     * @param  {} Body  body input
     * @param  {} strict  TRUE if body should contain all of the elements, FALSE for one or more
     */
    bodyVerify : async (Allowed, Body , strict) => {
      if(Body.length == 0)
      throw new Error(Dictionary().BODY_EMPTY)
    const isValidOperation = Body.every((element) => Allowed.includes(element))
     if(!isValidOperation)
         throw new Error(Dictionary().INVALID_OPERATION)
    if(strict === true)
     if(Body.length !== Allowed.length)
     throw new Error(Dictionary().ELMENTS_MISSING)
    if(strict === false)
      if(Body.length > Allowed.length)
        throw new Error(Dictionary().TOO_MANY_ELMENTS)
    return true
    },

    getCommentBody : async (CommentObject) => {
    let CommentsArray = []
    CommentObject.forEach((comment) => {
      if(comment.user && comment.user._id && comment.user.username && comment.user.profileImg && comment.content && comment.date){
         currentComment = {
          userId: comment.user._id,
          username: comment.user.username,
          profileImg: comment.user.profileImg,
          content: comment.content,
          date: Utils.formatDate(comment.date)
        }
        if(!checkUrl(currentComment.profileImg)){
        currentComment.profileImg = '/images/'+ currentComment.profileImg
      } 
        CommentsArray.push(currentComment)
      }
    })
      return CommentsArray
    },

    formatDate: (commentDate) => {
      let comDate = new Date(commentDate);
      let dayOfMonth = comDate.getDate();
      let month = comDate.getMonth() + 1;
      let year = comDate.getFullYear()
      let hour = comDate.getHours();
      let minutes = comDate.getMinutes();
      month = month < 10 ? "0" + month : month;
      dayOfMonth = dayOfMonth < 10 ? "0" + dayOfMonth : dayOfMonth;
      hour = hour < 10 ? "0" + hour : hour;
      minutes = minutes < 10 ? "0" + minutes : minutes;
      formattedDate =
        dayOfMonth + "-" + month + "-" + year + "  " + hour + ":" + minutes;
      return formattedDate;
    },

    checkFormatPassword : async (value) => {
      if(value == "") 
          throw new Error(Dictionary().REQ_PASS) 
      const passwordRgex = new RegExp(/^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-])/)
      if (!passwordRgex.test(value) || value.length < 8 ||  value.length > 128) {
          throw new Error(Dictionary().ERR_PASS)
      }
      return true
    },

    offlineTranslate: async (data, lang = 'en') => {
      if(lang !== 'en' && lang !== 'fr')
        lang = 'en'
      let translated = []
      if(data && Array.isArray(data))
        translated = data.map((element) => {
          if(element === 'Missing credentials'){
            return lang === 'fr' ? element = 'Informations manquantes' : 'Missing credentials'
          }
          else if(locales[lang] && locales[lang][element])
            return locales[lang][element]
          else 
            return locales[lang] && locales[lang].SWWPTA
        })
        return translated
    },
    getCookie: async (rc) => {
      let cookies = {}
      if(rc)
          rc && rc.split(';').forEach(( cookie ) => {
              let parts = cookie.split('=');
              cookies[parts.shift().trim()] = decodeURI(parts.join('='));
      });
      return cookies
    }
}

module.exports = Utils